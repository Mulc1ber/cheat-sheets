---
sidebar_position: 2
---

# Расширенный список команд для Git

Описание

> [Альтернативная шпаргалка](https://training.github.com/downloads/ru/github-git-cheat-sheet/)

---

## Команды git

```bash title="команда, позволяющая редактировать последний коммит"
git commit --amend
```

```bash title="команда, позваляющая переносить изменения из одного репозитория в другой"
git patch
```

```bash title="команда, позволяющая сбросить изменения как команда git restore <file>, но только для всех файлом из списка сразу одной командой"
git restore <file>
```

```bash title="команда, позволяющая сбросить изменения. Отменяет изменения в рабочей директории (working directory), которые еще не были проиндексированы (не добавлены в staging area)"
git restore .
```

```bash title="Убирает файл из staging area (индекса), но сохраняет изменения в рабочей директории"
git restore --staged <file>
```

> (если однажны git начал следить за файлом, то просто так, дабавляя его в .gitignore, он не перестанет за ним следить, тогда нужно удалить файл из индекса git. )

```bash title="удаляет файл из индекса git"
git rm --cached <path/file>
```

---

### Команда "stash"

Команда `stash` - позволяет временно прятать изменения. (временное хранилище в git, куда можно перевести все временные изменения. В том числе НЕотслеживаемые и ОТСЛЕЖИВАЕМЫЕ файлы, то есть те, которые были добавлены с помощью git add)

```bash title="Кладет в хранилище только отслеживаемые изменения"
git stash
```

```bash title="Кладет в хранилище как отслеживаемые изменения, так и новые (неотслеживаемые) файлы"
git stash -u
```

```bash title="Кладет в хранилище неотслеживаемые файлы, а также игнорируемые файлы (.gitignore)"
git stash -a
```

```bash title="Добавление комментария к stash"
git stash push -m "Ваш комментарий"
```

```bash title="Извлекает последнюю запись из stash и параллельно удаляет его из stash"
git stash pop
```

```bash title="Выводит список stash"
git stash list
```

```bash title="Удаляет последнюю stash/запись"
git stash drop
```

```bash title="Удаление определенного/нужного stash"
git stash drop stash@{0}
```

```bash title="Удаление всех stash"
git stash clear
```

```bash title="Применить изменения не удаляя его из stash"
git stash apply
```

---

### Передача изменений в виде файлов

```bash title="создает базовый вид патча (patch)"
git diff
```

```bash title="создает файл с расширением .patch, куда перемещены все изменения коммита, который мы указали в виде хэша"
git diff [хэш_коммита] > my_patch.patch
```

```bash title="применяет изменения из файла в свой проект"
git apply [name_file, my_patch.patch]
```

```bash title="все изменения, в том числе и коммиты"
git format-patch [hash_commit]
```

```bash title="применяются все изменения из файла, а так же автоматически коммитятся с информацией об авторе и дате коммита (вся эта инфа хранится в созданном файле с помощью команды git format-patch <hash commit>, где <hash commit> - коммит, с которого все начинается, если коммитов несколько.)"
git am [file] or [./directory/*]
```

---

### Редактирование коммитов

```bash title="Позволяет поменять/отредактировать коммит. (Примечание: ключ amend меняет/удаляет полностью предыдущий коммит и на его место ставит новый коммит. По этому amend если и использовать, то только когда разрабатывается на одном компе и одним человеком)"
git commit --amend
```

```bash title="Позволяет не менять текст самого коммита"
git commit --amend --no-edit
```

- `git commit --amend` - позволяет поменять/отредактировать коммит. (Примечание: ключ amend меняет/удаляет полностью предыдущий коммит и на его место ставит новый коммит. По этому amend если и использовать, то только когда разрабатывается на одном компе и одним человеком. )

- `git commit --amend --no-edit` - позволяет не менять текст самого коммита

---

### Настройки для коммитов

```bash title="команда, которая позваляет узнать какой редактор откроется для коммита"
git config --global core
```

```bash title="команда, которая позволяет установить нужный для разраба редактор, в котором будет совершаться коммит"
git config --global core.editor "code --wait -n"
```

---

### .gitignore

> Если в gitignore указать папку с "/" перед названием папки, то будет проигнорированы папки, которые находтся на одном уровне с файлом .gitignore, но если внутри любой другой будет папка с таким же названием, то данная папка не будет проигнорирована.
> Если **НЕ** ставить "/" перед названием папки, то будут проигнорированны все схожие папки во всем проекте.

---

## История

### Логирование

```bash title="Выводит в сжатом формате все логи конкретной ветки"
git log --oneline
```

```bash title="Показывает инфу, которая была сформирована при команде git format-patch или git diff. Данная команда удобна если делаем много маленьких (тость мало изменения в самом коммите) коммитов"
git log -p (patch)
```

```bash title="Позволяет узнать объем коммита, то есть на сколько он был большим или маленьким по объему. А так же будет инфа о файлах, в которых были изменения"
git log --stat
```

```bash title="Позволяет менять отображение информации в log"
git log --pretty=oneline
```

```bash title="Позволяет менять/форматировать информацию отображение в log"
git log --pretty=format:"%h (%ae): %s"
```

---

### Откат по истории

```bash title="Команда, которая позволяет откатить нужный коммит (указав его хэш). Но он этот коммит не удаляет, а создает после него новый, который убирает изменения, которые были в предыдущем коммите"
git revert [hash_commit]
```

> `git revert` используется, чтобы отменить изменения и поделиться отменёнными изменениями с остальными. (ИСПОЛЬЗУЕТСЯ ДЛЯ УДАЛЕННЫХ ВЕТКАХ)

```bash title="Отменяет изменения, перенося ссылку на ветку назад, на более старый коммит"
git reset [hash нужного нам коммита к которому мы хотим откатиться]
```

> `git reset` это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. (ИСПОЛЬЗУЕТСЯ ДЛЯ ЛОКАЛЬНЫХ ВЕТКАХ)

```bash title=""
git reset HEAD~[num] --hard
```

> где, num - это кол-во коммитов, которые нам нужно отступить до нужного нам коммита. Отсчет нужно вести с текущего коммита включительно. Ключ "--hard" указывает на откат назад и сброс всех изменени

```bash title=""
git reset [hash_commit || HEAD~[num]] --soft
```

> где soft - позволяет сбрасывать коммиты, а изменения оставляет, то есть остаются проиндексируемыми (Staged Changes) (Можно создать другой коммит, который необходим)

```bash title=""
git reset [hash || HEAD~[num]]
```

> Eсли не указывать доп ключи, то используется ключ mixed, он как софт убирает коммиты, но оставляет изменения, но сами изменения сбрасывает до Changes, то есть неиндексируемыми

---

```bash title=""
git rebase [hash_commit] -i
```

> где "i" - это interective, интерактивный. Позволяет в редакторе менять местами коммиты, вливать, удалять и др

```bash title=""
git rebase -i HEAD~4
```

> Пример еще одной реализации

```bash title=""
git rebase HEAD~[num]
```

```bash title=""
git rebase [branch1] [branch2]
```

> где, branch1 это ветка, куда нужно перемещать коммиты, а branch2 это ветка от куда перемещать коммиты. Пример: git rebase origin/main side1

---

```bash title="создаст ветку и преключается на него"
git switch -c
```

```bash title="просто создает ветку"
git branch
```

```bash title="команда выводит в виде списка информацию о всех действиях, которые у нас происходили в проекте"
git reflog
```

```bash title="пример команды, в которой принудительно перемещаем указатель ветки main на 3 коммита назад"
git branch -f main HEAD~3
```

---

## Ветвление

```bash title="Выводит список всех веток в проетке"
git branch -v
```

```bash title="удаляет ветку, но с предупреждением о том, что в ветке, которую удаляется, есть коммиты, которые не добавлены в другие ветки"
git branch -d [name_branch]
```

```bash title="удаляет ветку без предупреждений. (Ветки удаляются вместе с коммитами, которые были в ветках)"
git branch -D [name_branch]
```

```bash title="создает ветку из коммита. (Например из удаленной ветки может достать хэш коммита и его вставить в команду и таким образом создастся ветка с этим коммитом)"
git branch [name_branch] [hash_commit]
```

> У `merge` есть технология слияния веток, такой как `fast-forward` - передвигает ветку по коммитам или перемещение указателя от одного коммита к другому. Он используется, когда при слиянии нет никаких конфликтов, то есть, если мы можешь наложить все коммиты ветки, которую хотим слить поверх, то выполняется данная технология.

```bash title="все коммиты, которые есть в ветке (отведенной от main) поставить сверху ветки main, то есть после последнего коммита в ветке main. То есть, начальный коммит для отведенной ветки (прим. test) стал последний коммит ветки main"
git rebase [name_branch]
```

> Используя cherry-pick, то перед тем как заливать его в main ветку, необходимо провести rebase, таким образом можно избавится от лишнего коммита с инфой о merge.

```bash title="создается копия коммита, с точно такими же изменениями, копирует текст коммита, но при этом создает новый коммит"
git cherry-pick [hash_commit]
```

```bash title="команда, которая объединяет изменения в отвлетвленной ветки <branch> с веткой в которой ты находишься, при этом, если merge выполняется не fast-forward, то данное слияние не произойдет благодоря параметру/ключу --ff-only"
git merge --ff-only [branch]
```

---

## Удаленный репозиторий

```bash title="команда, позволяющая менять в url ссылку, вместо удаления и повторного добавления"
git remote set-url [name_rep (origin)] [url]
```

```bash title="команда, позволяющая переименовывать удаленный репозиторий"
git remote rename [old_name] [new_name]
```

```bash title="команда, позволяющая получить изменения, но не перемещать наш master/main с текущего коммита. Выполнив эту команду, мы получим с удаленного репозитория информацию о всех изменениях, которые только существуют в этом удаленном репозитории, НО при это ЛОКАЛЬНЫЙ master/main ОСТАНЕТСЯ там же где и был. (Наша локальная ветка не изменится, если выполнить git fetch)"
git fetch
```

```bash title="команда, позволяющая перейти/переключить состояние нашей локальной ветки на актуальный"
git pull
```

```bash title="данная команда аналогична команде git pull (git fetch, git merge), но она не делает merge, а вместо этого передвигает локальную ветку к удаленной (git fetch, git rebase)"
git pull --rebase
```

```bash title="наша ветка master отслеживает какую то ветку в удаленном репозитории origin. Достаточно выполнить данную команду один раз и после все git pull будут срабатывать одинакого"
git branch --set-upstream-to=origin/<branch> master
```

```bash title="пушит все изменения, которые есть локально, ВКЛЮЧАЯ ВЕТКИ"
git push --all
```

```bash title="Пушит все локальные изменения на удаленную ветку"
git push origin main
```

```bash title="указывает от куда (из какой ветки) брать коммиты (foo) и в какую ветку его пушить"
git push origin foo:main
```

```bash title="на удаленном репозитории в ветке foo соберет все коммиты, которые отсутствуют локально, и поместит из в локальную ветку origin/foo. (НЮАНС: fetch не обновляет ветку foo, а только скачивает коммиты)"
git fetch origin foo
```

```bash title="где main - это ветка из удаленного репозитория, от куда брать коммиты, а foo - это ветка локальная, куда тянуть все коммиты из удаленной ветки main (ПРИМЕЧАНИЕ: если локальной ветки с таким именем нет foo, то git ее автоматически создаст)"
git pull origin main:foo
```

```bash title="команда, которая создает новую ветку с дальшейшим переходом на нее, а после указываем, что данная ветка отслеживает/привязана к origin/main. Это способ указать ветке отслеживать удалённую ветку"
git checkout -b foo origin/main
```

```bash title="Это еще один способ указать ветке отслеживать удалённую ветку. Где foo - это ветка, которой мы указываем следить за origin/main, НО если вы находитесь на этой ветке (foo), то ее указывать как доп параметр не нужно - git branch -u"
git branch -u origin/main foo
```

```bash title="нужен для добавления patch файлов с расширением .diff"
git apply
```

```bash title="тоже самое, где ключи --ignore-space-change и --ignore-whitespace убирают пробелы, чтобы небыло конфликтов"
git apply --ignore-space-change --ignore-whitespace "name file with .diff"
```

---

## Релизы / Теги

```bash title="создаем тэг, который привяжется к коммиту, на который, в момент создания, стоит указатель"
git tag 1.0.0
```

```bash title="просто указываем на коммит, к которому привязан тэг"
git show 1.0.0
```

```bash title="расширенная версия создания тэга с доп инфой"
git tag -a test -m "test release"
```

```bash title="пушим тэги на удаленный репозиторий"
git push --tags
```

```bash title="удаляем в удаленном репозитории тэг"
git push origin --delete [name_tag]
```
