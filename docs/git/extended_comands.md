# Расширенный список команд для Git

Описание

> [Альтернативная шпаргалка](https://training.github.com/downloads/ru/github-git-cheat-sheet/)

---

## [ Команды git ]

- `git commit --amend` - команда, позволяющая редактировать последний коммит;

- `git patch` - команда, позваляющая переносить изменения из одного репозитория в другой;

- `git restore <file>` - команда, позволяющая сбросить изменения. Отменяет изменения в рабочей директории (working directory), которые еще не были проиндексированы (не добавлены в staging area).;

- `git restore .` - команда, позволяющая сбросить изменения как команда `git restore <file>`, но только для всех файлом из списка сразу одной командой.

- `git restore --staged <file>` - Убирает файл из staging area (индекса), но сохраняет изменения в рабочей директории.

> (если однажны git начал следить за файлом, то просто так, дабавляя его в .gitignore, он не перестанет за ним следить, тогда нужно удалить файл из индекса git. )

- `git rm --cached <path/file>` - удаляет файл из индекса git.

---

### Команда "stash"

- `git stash` - команда, позволяющая временно прятать изменения. (временное хранилище в git, куда мы можешь перевести все ОТСЛЕЖИВАЕМЫЕ файл, то есть те, которые были добавлены с помощью git add)

- `git stash list` - (просмотр всех коммитов/изменений, которые были перемещены в git stash)

- `git stash pop` - извлекает последнюю запись из stash и параллельно удаляет его из stash.

- `git stash drop` - удаляет последнюю запись или удаляет конкретный файл (нужно ввести с ключом?)

- `git stash apply` - применить изменения не удаляя его из stash.

---

### Передача изменений в виде файлов

- `git diff` - создает базовый вид патча (patch)

- `git diff <хэш коммита> > my_patch.patch` - создает файл с расширением .patch, куда перемещены все изменения коммита, который мы указали в виде хэша.

- `git apply <name file, my_patch.patch>` - применяет изменения из файла в свой проект.

- `git format-patch <hash commit>` - все изменения, в том числе и коммиты

- `git am <file> or <./directory/*>` - применяются все изменения из файла, а так же автоматически коммитятся с информацией об авторе и дате коммита (вся эта инфа хранится в созданном файле с помощью команды git format-patch `<hash commit>`, где `<hash commit>` - коммит, с которого все начинается, если коммитов несколько.).

---

### Редактирование коммитов

- `git commit --amend` - позволяет поменять/отредактировать коммит. (Примечание: ключ amend меняет/удаляет полностью предыдущий коммит и на его место ставит новый коммит. По этому amend если и использовать, то только когда разрабатывается на одном компе и одним человеком. )

- `git commit --amend --no-edit` - позволяет не менять текст самого коммита

---

### Настройки для коммитов

- `git config --global core.` - команда, которая позваляет узнать какой редактор откроется для коммита

- `git config --global core.editor "code --wait -n"` - команда, которая позволяет установить нужный для разраба редактор, в котором будет совершаться коммит.

---

### .gitignore

> Если в gitignore указать папку с "/" перед названием папки, то будет проигнорированы папки, которые находтся на одном уровне с файлом .gitignore, но если внутри любой другой будет папка с таким же названием, то данная папка не будет проигнорирована.
> Если **НЕ** ставить "/" перед названием папки, то будут проигнорированны все схожие папки во всем проекте.

---

## [ История ]

- `git log --oneline` - выводит в сжатом формате все логи конкретной ветки.

- `git log -p (patch)` - показывает инфу, которая была сформирована при команде git format-patch или git diff. Данная команда удобна если делаем много маленьких (тость мало изменения в самом коммите) коммитов.

- `git log --stat` - позволяет узнать объем коммита, то есть на сколько он был большим или маленьким по объему. А так же будет инфа о файлах, в которых были изменения.

- `git log --pretty=oneline` - позволяет менять отображение информации в log.

- `git log --pretty=format:"%h (%ae): %s"` - позволяет менять/форматировать информацию отображение в log.

- `git revert <hash commit>` - команда, которая позволяет откатить нужный коммит (указав его хэш). Но он этот коммит не удаляет, а создает после него новый, который убирает изменения, которые были в предыдущем коммите.

  > \*\*\* `git revert` используется, чтобы отменить изменения и поделиться отменёнными изменениями с остальными. (ИСПОЛЬЗУЕТСЯ ДЛЯ УДАЛЕННЫХ ВЕТКАХ)

- `git reset <hash нужного нам коммита, к которому мы хотим откатиться>`
  \*\*\* `git reset` отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. (ИСПОЛЬЗУЕТСЯ ДЛЯ ЛОКАЛЬНЫХ ВЕТКАХ)

- `git reset HEAD~<num> --hard` - где, num - это кол-во коммитов, которые нам нужно отступить до нужного нам коммита. Отсчет нужно вести с текущего коммита включительно. Ключ "--hard" указывает на откат назад и сброс всех изменени.

- `git reset <hash commit || HEAD~<num>> --soft` - где soft - позволяет сбрасывать коммиты, а изменения оставляет, то есть остаются проиндексируемыми (Staged Changes) (Можно создать другой коммит, который необходим).

- `git reset <hash || HEAD~<num>>` - если не казывать доп ключи, то используется ключ mixed, он как софт убирает коммиты, но оставляет изменения, но сами изменения сбрасывает до Changes, то есть неиндексируемыми.

- `git rebase <hash commit> -i` - где "i" - это interective, интерактивный. Позволяет в редакторе менять местами коммиты, вливать, удалять и др.

- `git rebase -i HEAD~4` - пример еще одной реализации.

- `git rebase HEAD~<num>`

- `git rebase <branch1> <branch2>` - где, branch1 это ветка, куда нужно перемещать коммиты, а branch2 это ветка от куда перемещать коммиты. Пример: git rebase origin/main side1.

- `git checkout <hash commit>` - (checkout используется для перемещения не тольо по веткам, но и по коммитам)

- `git switch -c` - создаст ветку и преключается на него

- `git branch` - просто создает ветку.

- `git reflog` - команда выводит в виде списка информацию о всех действиях, которые у нас происходили в проекте.

- `git branch -f main HEAD~3` - пример команды, в которой принудительно перемещаем указатель ветки main на 3 коммита назад.

---

## [ Ветвление ]

- `git checkout <name branch>` - Переходит на ветку, которую указали

- `git checkout -b <name branch>` - Создает ветку и сразу переходит на нее.

- `git branch -v` - Выводит список всех веток в проетке.

- `git branch -d <name branch>` - удаляет ветку, но с предупреждением о том, что в ветке, которую удаляется, есть коммиты, которые не добавлены в другие ветки.

- `git branch -D <name branch>` - удаляет ветку без предупреждений. (Ветки удаляются вместе с коммитами, которые были в ветках)

- `git branch <name branch> <hash commit>` - создает ветку из коммита. (Например из удаленной ветки может достать хэш коммита и его вставить в команду и таким образом создастся ветка с этим коммитом)

> \*\*\* У `merge` есть технология слияния веток, такой как - `"fast-forward"` (передвигает ветку по коммитам или перемещение указателя от одного коммита к другому), он используется, когда при слиянии нет никаких конфликтов, то есть, если мы можешь наложить все коммиты ветки, которую хотим слить поверх, то выполняется данная технология.

- `git rebase <name branch ~ прим. main>` - все коммиты, которые есть в ветке (отведенной от main) поставить сверху ветки main, то есть после последнего коммита в ветке main. То есть, начальный коммит для отведенной ветки (прим. test) стал последний коммит ветки main.

> \*\*\* Используя cherry-pick, то перед тем как заливать его в main ветку, необходимо провести rebase, таким образом можно избавится от лишнего коммита с инфой о merge.

- `git cherry-pick <hash commit>` - создается копия коммита, с точно такими же изменениями, копирует текст коммита, но при этом создает новый коммит.

- `git merge --ff-only <branch>` - команда, которая объединяет изменения в отвлетвленной ветки `<branch>` с веткой в которой ты находишься, при этом, если merge выполняется не fast-forward, то данное слияние не произойдет благодоря параметру/ключу --ff-only.

---

## [ Удаленный репозиторий ]

- `git remote set-url <name rep (origin)> <url>` - команда, позволяющая менять в url ссылку, вместо удаления и повторного добавления.

- `git remote rename <old name> <new name>` - команда, позволяющая переименовывать удаленный репозиторий.

- `git fetch` - команда, позволяющая получить изменения, но не перемещать наш master/main с текущего коммита. Выполнив эту команду, мы получим с удаленного репозитория информацию о всех изменениях, которые только существуют в этом удаленном репозитории, НО при это ЛОКАЛЬНЫЙ master/main ОСТАНЕТСЯ там же где и был. (Наша локальная ветка не изменится, если выполнить git fetch)

- `git pull` - команда, позволяющая перейти/переключить состояние нашей локальной ветки на актуальный.

- `git pull --rebase` - данная команда аналогична команде git pull (git fetch, git merge), но она не делает merge, а вместо этого передвигает локальную ветку к удаленной (git fetch, git rebase).

- `git branch --set-upstream-to=origin/<branch> master` - наша ветка master отслеживает какую то ветку в удаленном репозитории origin. Достаточно выполнить данную команду один раз и после все git pull будут срабатывать одинакого.

- `git push --all` - пушит все изменения, которые есть локально, ВКЛЮЧАЯ ВЕТКИ

- `git push origin main` -

- `git push origin foo:main` - указывает от куда (из какой ветки) брать коммиты (foo) и в какую ветку его пушить.

- `git fetch origin foo` - на удаленном репозитории в ветке foo соберет все коммиты, которые отсутствуют локально, и поместит из в локальную ветку origin/foo. (НЮАНС: fetch не обновляет ветку foo, а только скачивает коммиты).

- `git pull origin main:foo` - где main - это ветка из удаленного репозитория, от куда брать коммиты, а foo - это ветка локальная, куда тянуть все коммиты из удаленной ветки main (ПРИМЕЧАНИЕ: если локальной ветки с таким именем нет "foo", то git ее автоматически создаст)

- `git checkout -b foo origin/main` - команда, которая создает новую ветку с дальшейшим переходом на нее, а после указываем, что данная ветка отслеживает/привязана к origin/main. Это способ указать ветке отслеживать удалённую ветку.

- `git branch -u origin/main foo` - Это еще один способ указать ветке отслеживать удалённую ветку. Где foo - это ветка, которой мы указываем следить за origin/main, НО если вы находитесь на этой ветке (foo), то ее указывать как доп параметр не нужно - git branch -u.

- `git apply` - нужен для добавления patch файлов с расширением .diff

- `git apply --ignore-space-change --ignore-whitespace "name file with .diff"` - тоже самое, где ключи "--ignore-space-change" и "--ignore-whitespace" убирают пробелы, чтобы небыло конфликтов.

---

## [ РЕЛИЗЫ / ТЕГИ ]

- `git tag 1.0.0` - создаем тэг, который привяжется к коммиту, на который, в момент создания, стоит указатель.

- `git show 1.0.0` - просто указываем на коммит, к которому привязан тэг.

- `git tag -a test -m "test release"` - расширенная версия создания тэга с доп инфой.

- `git push --tags` - пушим тэги на удаленный репозиторий.

- `git push origin --delete <name tag>` - удаляем в удаленном репозитории тэг
