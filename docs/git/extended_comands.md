---
sidebar_position: 2
---

# Расширенный список команд для Git

Описание

> [Альтернативная шпаргалка](https://training.github.com/downloads/ru/github-git-cheat-sheet/)

---

## Настройка Git

### Настройка пользователя

> Вы можете установить локальное имя и email пользователя при работе с конкретным репозиторием, для которого требуются учетные данные, отличные от ваших обычных, например, для работы и личных проектов.

```bash title="Настройка локальной конфигурации git"
git config --local user.name "Your Name"
git config --local user.email "Your Email"
```

Существует порядок приоритетов настройки конфигурации git: `local` → `global` → `system`.

```bash title="Просмотр локальных настроек (current repository)"
git config --local --list
```

```bash title="Просмотр глобальных настроек (user-specific)"
git config --global --list
```

```bash title="Просмотр системных настроек (system-wide)"
git config --system --list
```

```bash title="Просмотр ВСЕХ настроек с учётом приоритетов"
git config --list
# Показывает все настройки в порядке: local → global → system
```

### Хранение файлов конфигураций

Файлы конфигурации `git` хранятся в следующий местах:

```bash title="Local (локальный)"
.git/config
```

```bash title="Global (глобальный)"
~/.gitconfig  # Linux/Mac
C:\Users\ИмяПользователя\.gitconfig  # Windows
```

```bash title="System (системный)"
/etc/gitconfig  # Linux/Mac
C:\Program Files\Git\etc\gitconfig  # Windows
```

## Работа с файлами и индексом

```bash title="Сбросить изменения в файле до состояния последнего коммита"
git restore <file>
```

```bash title="Cбросить изменения. Отменяет изменения в рабочей директории (working directory), которые еще не были проиндексированы (не добавлены в staging area)"
git restore .
```

```bash title="Убирает файл из staging area (индекса), но сохраняет изменения в рабочей директории"
git restore --staged <file>
```

> (если однажны git начал следить за файлом, то просто так, дабавляя его в .gitignore, он не перестанет за ним следить, тогда нужно удалить файл из индекса git. )

```bash title="удаляет файл из индекса git"
git rm --cached <path/file>
```

```bash title="команда, позваляющая переносить изменения из одного репозитория в другой"
git patch
```

---

## Работа с коммитами

### Редактирование коммитов

```bash title="команда, позволяющая редактировать последний коммит"
git commit --amend
```

> Примечание: ключ amend меняет/удаляет полностью предыдущий коммит и на его место ставит новый коммит. По этому amend если и использовать, то только когда разрабатывается на одном компе и одним человеком)

```bash
git commit --amend --no-edit
```

- `git commit --amend` - позволяет поменять/отредактировать коммит. (Примечание: ключ amend меняет/удаляет полностью предыдущий коммит и на его место ставит новый коммит. По этому amend если и использовать, то только когда разрабатывается на одном компе и одним человеком. )

- `git commit --amend --no-edit` - позволяет не менять текст самого коммита

### Настройки коммитов

```bash title="команда, которая позваляет узнать какой редактор откроется для коммита"
git config --global core.editor
```

```bash title="команда, которая позволяет установить нужный для разраба редактор, в котором будет совершаться коммит"
git config --global core.editor "code --wait -n"
```

---

## Временное сохранение изменений

Команда `stash` - позволяет временно прятать изменения. (временное хранилище в git, куда можно перевести все временные изменения. В том числе НЕотслеживаемые и ОТСЛЕЖИВАЕМЫЕ файлы, то есть те, которые были добавлены с помощью git add)

```bash title="Кладет в хранилище только отслеживаемые изменения"
git stash
```

```bash title="Кладет в хранилище как отслеживаемые изменения, так и новые (неотслеживаемые) файлы"
git stash -u
```

```bash title="Кладет в хранилище неотслеживаемые файлы, а также игнорируемые файлы (.gitignore)"
git stash -a
```

```bash title="Добавление комментария к stash"
git stash push -m "Ваш комментарий"
```

```bash title="Выводит список stash"
git stash list
```

```bash title="Извлекает последнюю запись из stash и параллельно удаляет его из stash"
git stash pop
```

```bash title="Применить изменения не удаляя его из stash"
git stash apply
```

```bash title="Удаляет последнюю stash/запись"
git stash drop
```

```bash title="Удаление определенного/нужного stash"
git stash drop stash@{0}
```

```bash title="Удаление всех stash"
git stash clear
```

---

## История и логирование

### Просмотр истории (логирование)

```bash title="Показывает инфу, которая была сформирована при команде git format-patch или git diff. Данная команда удобна если делаем много маленьких (то есть мало изменения в самом коммите) коммитов"
git log -p (patch)
```

```bash title="Позволяет узнать объем коммита, то есть на сколько он был большим или маленьким по объему. А так же будет инфа о файлах, в которых были изменения"
git log --stat
```

```bash title="Позволяет менять отображение информации в log"
git log --pretty=oneline
```

```bash title="Позволяет менять/форматировать информацию отображение в log"
git log --pretty=format:"%h (%ae): %s"
```

### Откат изменений (по истории)

```bash title="Команда, которая позволяет откатить нужный коммит (указав его хэш). Но он этот коммит не удаляет, а создает после него новый, который убирает изменения, которые были в предыдущем коммите"
git revert [hash_commit]
```

> `git revert` используется, чтобы отменить изменения и поделиться отменёнными изменениями с остальными. (ИСПОЛЬЗУЕТСЯ ДЛЯ УДАЛЕННЫХ ВЕТКАХ)

```bash title="Отменяет изменения, перенося ссылку на ветку назад, на более старый коммит, который мы указываем"
git reset [hash_commit]
```

> `git reset` это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было. (ИСПОЛЬЗУЕТСЯ ДЛЯ ЛОКАЛЬНЫХ ВЕТКАХ)

```bash title=""
git reset HEAD~[num] --hard
```

> где, num - это кол-во коммитов, которые нам нужно отступить до нужного нам коммита. Отсчет нужно вести с текущего коммита включительно. Ключ "--hard" указывает на откат назад и сброс всех изменени

```bash title=""
git reset [hash_commit || HEAD~[num]] --soft
```

> где soft - позволяет сбрасывать коммиты, а изменения оставляет, то есть остаются проиндексируемыми (Staged Changes) (Можно создать другой коммит, который необходим)

```bash title=""
git reset [hash || HEAD~[num]]
```

> Eсли не указывать доп ключи, то используется ключ mixed, он как софт убирает коммиты, но оставляет изменения, но сами изменения сбрасывает до Changes, то есть неиндексируемыми

```bash title="команда выводит в виде списка информацию о всех действиях, которые у нас происходили в проекте"
git reflog
```

---

## Работа с ветками

### Создание и удаление веток

```bash title="создаст ветку и преключается на него"
git switch -c [branch_name]
```

```bash title="просто создает ветку"
git branch [branch_name]
```

```bash title="создает ветку из коммита. (Например из удаленной ветки может достать хэш коммита и его вставить в команду и таким образом создастся ветка с этим коммитом)"
git branch [branch_name] [hash_commit]
```

```bash title="пример команды, в которой принудительно перемещаем указатель ветки main на 3 коммита назад"
git branch -f main HEAD~3
```

```bash title="Выводит список всех веток в проетке"
git branch -v
```

```bash title="удаляет ветку, но с предупреждением о том, что в ветке, которую удаляется, есть коммиты, которые не добавлены в другие ветки"
git branch -d [name_branch]
```

```bash title="удаляет ветку без предупреждений. (Ветки удаляются вместе с коммитами, которые были в ветках)"
git branch -D [name_branch]
```

### Слияние и перебазирование

```bash title=""
git merge [branch_name]
```

```bash title="команда, которая объединяет изменения в отвлетвленной ветки <branch> с веткой в которой ты находишься, при этом, если merge выполняется не fast-forward, то данное слияние не произойдет благодоря параметру/ключу --ff-only"
git merge --ff-only [branch]
```

> У `merge` есть технология слияния веток, такой как `fast-forward` - передвигает ветку по коммитам или перемещение указателя от одного коммита к другому. Он используется, когда при слиянии нет никаких конфликтов, то есть, если мы можешь наложить все коммиты ветки, которую хотим слить поверх, то выполняется данная технология.

```bash title="все коммиты, которые есть в ветке (отведенной от main) поставить сверху ветки main, то есть после последнего коммита в ветке main. То есть, начальный коммит для отведенной ветки (прим. test) стал последний коммит ветки main"
git rebase [name_branch]
```

```bash title=""
git rebase -i [hash_commit]
```

```bash title=""
git rebase [hash_commit] -i
```

> где "i" - это interective, интерактивный. Позволяет в редакторе менять местами коммиты, вливать, удалять и др

```bash title=""
git rebase -i HEAD~4
```

> Пример еще одной реализации

```bash title=""
git rebase HEAD~[num]
```

```bash title=""
git rebase [branch1] [branch2]
```

> где, branch1 это ветка, куда нужно перемещать коммиты, а branch2 это ветка от куда перемещать коммиты. Пример: git rebase origin/main side1

> Используя cherry-pick, то перед тем как заливать его в main ветку, необходимо провести rebase, таким образом можно избавится от лишнего коммита с инфой о merge.

```bash title="создается копия коммита, с точно такими же изменениями, копирует текст коммита, но при этом создает новый коммит"
git cherry-pick [hash_commit]
```

---

## Удаленный репозиторий

### Настройка удаленных репозиториев

```bash title="команда, позволяющая менять в url ссылку, вместо удаления и повторного добавления"
git remote set-url [name] [new_url]
```

```bash title="команда, позволяющая переименовывать удаленный репозиторий"
git remote rename [old_name] [new_name]
```

### Получение изменений

```bash title="команда, позволяющая получить изменения, но не перемещать наш master/main с текущего коммита. Выполнив эту команду, мы получим с удаленного репозитория информацию о всех изменениях, которые только существуют в этом удаленном репозитории, НО при это ЛОКАЛЬНЫЙ master/main ОСТАНЕТСЯ там же где и был. (Наша локальная ветка не изменится, если выполнить git fetch)"
git fetch
```

```bash title="команда, позволяющая перейти/переключить состояние нашей локальной ветки на актуальный"
git pull
```

```bash title="данная команда аналогична команде git pull (git fetch, git merge), но она не делает merge, а вместо этого передвигает локальную ветку к удаленной (git fetch, git rebase)"
git pull --rebase
```

```bash title="где main - это ветка из удаленного репозитория, от куда брать коммиты, а foo - это ветка локальная, куда тянуть все коммиты из удаленной ветки main (ПРИМЕЧАНИЕ: если локальной ветки с таким именем нет foo, то git ее автоматически создаст)"
git pull origin main:foo
```

```bash title="на удаленном репозитории в ветке [branch_name] соберет все коммиты, которые отсутствуют локально, и поместит из в локальную ветку origin/[branch_name]. (НЮАНС: fetch не обновляет ветку [branch_name], а только скачивает коммиты)"
git fetch origin [branch_name]
```

### Отправка изменений

```bash title="Пушит все локальные изменения на удаленную ветку"
git push origin main
```

```bash title="пушит все изменения, которые есть локально, ВКЛЮЧАЯ ВЕТКИ"
git push --all
```

```bash title="указывает от куда (из какой ветки) брать коммиты (local_branch) и в какую ветку его пушить"
git push origin [local_branch]:[remote_branch]
```

### Отслеживание веток

```bash title="наша ветка master отслеживает какую то ветку в удаленном репозитории origin. Достаточно выполнить данную команду один раз и после все git pull будут срабатывать одинакого"
git branch --set-upstream-to=origin/<branch> master
```

```bash title="команда, которая создает новую ветку с дальшейшим переходом на нее, а после указываем, что данная ветка отслеживает/привязана к origin/[remote_branch]. Это способ указать ветке отслеживать удалённую ветку"
git checkout -b [local_branch] origin/[remote_branch]
```

```bash title="Это еще один способ указать ветке отслеживать удалённую ветку. Где foo - это ветка, которой мы указываем следить за origin/main, НО если вы находитесь на этой ветке (foo), то ее указывать как доп параметр не нужно - git branch -u"
git branch -u origin/main foo
```

---

## Патчи и файлы изменений

```bash title="создает базовый вид патча (patch)"
git diff
```

```bash
git diff > changes.patch
```

```bash title="создает файл с расширением .patch, куда перемещены все изменения коммита, который мы указали в виде хэша"
git diff [hash_commit] > my_patch.patch
```

```bash title="нужен для добавления patch файлов с расширением .diff"
git apply [patch_file]
```

```bash title="тоже самое, где ключи --ignore-space-change и --ignore-whitespace убирают пробелы, чтобы небыло конфликтов"
git apply --ignore-space-change --ignore-whitespace "name file with .diff"
```

```bash title="применяет изменения из файла в свой проект"
git apply [name_file, my_patch.patch]
```

```bash title="все изменения, в том числе и коммиты"
git format-patch [hash_commit]
```

```bash title="применяются все изменения из файла, а так же автоматически коммитятся с информацией об авторе и дате коммита (вся эта инфа хранится в созданном файле с помощью команды git format-patch <hash commit>, где <hash commit> - коммит, с которого все начинается, если коммитов несколько.)"
git am [file] or [./directory/*]
```

---

## Теги (релизы)

```bash title="создаем тэг, который привяжется к коммиту, на который, в момент создания, стоит указатель"
git tag 1.0.0
```

```bash title="расширенная версия создания тэга с доп инфой"
git tag -a test -m "test release"
```

```bash title="просто указываем на коммит, к которому привязан тэг"
git show 1.0.0
```

```bash title="пушим тэги на удаленный репозиторий"
git push --tags
```

```bash title="удаляем в удаленном репозитории тэг"
git push origin --delete [name_tag]
```

---

## .gitignore

> Важно: Если в .gitignore указать папку с "/" перед названием (например, /node_modules/), будут игнорироваться только папки на том же уровне, что и .gitignore. Без "/" (например, node_modules/) будут игнорироваться все такие папки в проекте.
